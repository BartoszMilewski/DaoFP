\documentclass[DaoFP]{subfiles}
\begin{document}
\setcounter{chapter}{13}

\chapter{Monads}

What do a wheel, a clay pot, and a wooden house have in common? They are all useful because of the emptiness in their center. 

Lao Tzu says: ``The value comes from what is there, but the use comes from what is not there.''

What does the \hask{Maybe} functor, the list functor, and the reader functor have in common? They all have emptiness in their center. 

When monads are explained in the context of programming, it's hard to see the common pattern when you focus on the functors. To understand monads you have to look inside functors and in between functions.



\section{Programming with Side Effects}

So far we've been talking about programming in terms of computations that were modeled mainly on functions between sets (with the exception of non-termination). In programming, such functions are called \emph{total} and \emph{pure}. 

A total function is defined for all values of its arguments. 

A pure function is implemented purely in terms of its arguments---it has no access to, much less having the ability to modify, its environment. 

Most real-world programs, though, have to interact with the external world: they read and write files, process network packets, prompt users for data, etc. Most programming languages solve this problem by allowing side effect. A side effect is anything that breaks the totality or the purity of a function. 

Unfortunately, this shotgun approach adopted by imperative languages makes reasoning about programs extremely hard. When composing effectful computations one has to carefully reason about the composition of effects, on a case-by-case basis. To make things even harder, most effects are hidden inside the implementation of a function and all the functions it's calling, recursively.

The solution adopted by purely functional languages, like Haskell, is to encode side effects in the return type of a pure function. Amazingly, this is possible for all relevant effects. The idea is that, instead of a computation of the type \hask{a->b} with side effects, we use a function \hask{a->f b}, where the functor \hask{f} encodes the appropriate effect. Below is the list of common effects and their pure-function versions.

\subsection{Partiality}
In imperative languages, partiality is often encoded using exceptions. When a function is called with the ``wrong'' value for its argument, it throws an exception. In some languages, the type of exception is encoded in the signature of the function using special syntax. 

In Haskell, a partial computation can be implemented by a function returning the result inside the \hask{Maybe} functor. Such a function, when called with the ``wrong'' argument, returns \hask{Nothing}, otherwise is wraps the result in the \hask{Just} constructor.

If we want to encode more information about the type of the failure, we can use the \hask{Either} functor, with the \hask{Left} traditionally passing the error data (often a simple \hask{String}); and \hask{Right} encapsulating the real return, if available.

The caller of a \hask{Maybe}-valued function cannot easily ignore the exceptional condition. In order to extract the value, they have to pattern-match the result and decide how to deal with \hask{Nothing}. This is in contrast to the ``poor-man's \hask{Maybe}'' of some imperative languages where the error condition is encoded using a null pointer.

\subsection{Logging}

Sometimes a computation has to log some values in some external data structure. Logging or auditing is a side effect that's particularly dangerous in concurrent programs, where multiple threads might try to access the same log simultaneously.

The simple solution is for a function to return the computed value paired with the item to be logged. In other words, a logging computation of the type \hask{ a -> b } can be replaced by a pure function:
\begin{haskell}
a -> Writer w b
\end{haskell}
where the \hask{Writer} functor is a thin encapsulation of the product:
\begin{haskell}
newtype Writer w a = Writer (a, w)
\end{haskell}
with \hask{w} being the type of the log.

The caller of this function is then responsible for extracting the value to be logged. This is a common trick: make the function provide all the data, and let the caller deal with the effects.

\subsection{Environment}

Some computations need read-only access to some external data stored in the environment. The read-only environment, instead of being secretly accessed by a computation, can be simply passed to a function as an additional argument. If we have a computation \hask{ a -> b } that needs access to some environment \hask{e}, we replace it with a function \hask{ (a, e) -> b }. At first, this doesn't seem to fit the pattern of encoding side effects in the return type. However, such a function can always be curried to the form:
\begin{haskell}
a -> (e -> b)
\end{haskell}
Such return type can be encoded as the reader functor, itself parameterized by the environment type \hask{e}:
\begin{haskell}
newtype Reader e a = Reader (e -> a)
\end{haskell}
The callers of the function are then responsible for extracting the value from the reader. They do it by passing it the environment:
\begin{haskell}
runReader :: Reader e a -> e -> a
runReader (Reader h) e = h e
\end{haskell}

\subsection{State}

The most common side effect is related to accessing and potentially modifying some shared state. Unfortunately, shared state is the notorious source of concurrency errors. This is a serious problem in object oriented languages where stateful objects can be transparently shared between many clients. In Java, such objects may be provided with individual mutexes at the cost of impaired performance and the risk of deadlocks.

In functional programming we make state manipulations explicit: we pass the state as an additional argument and return the modified state paired with the return value. We replace a stateful computation \hask{ a -> b } with
\begin{haskell}
(a, s) -> (b, s)
\end{haskell}
where \hask{s} is the type of state. As before, we can curry such a function to get it to the form:
\begin{haskell}
a -> s -> (b, s)
\end{haskell}
This return type can be encapsulated in the following functor:
\begin{haskell}
newtype State s a = State (s -> (a, s))
\end{haskell}
The caller of such a function is supposed to retrieve the result and the modified state by providing the initial state and calling the helper function \hask{runState}:
\begin{haskell}
runState :: State s a -> s -> (a, s)
runState (State h) s = h s
\end{haskell}
Notice that, modulo constructor unpacking, \hask{runState} is bona fide function application. 

\subsection{Nondeterminism}

Imagine performing a quantum experiment that measures the spin of an electron. Half of the time the spin will be up, and half of the time it will be down. The result is non-deterministic. One way to describe it is to use the many-worlds interpretation: when we perform the experiment, the Universe splits into two Universes, one for each result.  

What does it mean for a function to be non-deterministic? It means that it will return different results every time it's called. We can model this behavior using the many-worlds interpretation: we let the function return \emph{all possible results} at once. In practice, we'll settle for a (possibly infinite) list of results:

We replace a non-deterministic computation \hask{ a -> b } with a pure function returning a functor-ful of results---this time it's the list functor:
\begin{haskell}
a -> [b]
\end{haskell}
Again, it's up to the caller to decide what to do with these results.

\subsection{Input/Output}

This is the trickiest side effect because it involves interacting with the external world. Obviously, we cannot model the whole world inside a computer program. So, in order to keep the program pure, the interaction has to happen outside of it. The trick is to let the program generate a script. This script is then passed to the runtime to be executed. The runtime is the effectful virtual machine that runs the program. 

This script itself sits inside the opaque, predefined \hask{IO} functor. The values hidden in this functor are not accessible to the program: there is no \hask{runIO} function. Instead, the \hask{IO} value produced by the program is executed by the runtime. Conceptually, this happens \emph{after} the program is finished. Because of Haskell's laziness, though, the pure functions that form the program are evaluated on demand---the demand being driven by the execution of the \hask{IO} script.

The \hask{IO} object that is produced by a Haskell program is called \hask{main} and this is its type signature:
\begin{haskell}
main :: IO ()
\end{haskell}
It's the \hask{IO} functor containing the unit---meaning: there is no useful value other than the input/output script.

We'll talk about how \hask{IO} actions are created soon.

\subsection{Continuation}

We've seen that, as a consequences of the Yoneda lemma, we can replace a value of type \hask{a} with a function that takes a handler for that value. This handler is called a continuation. Calling a handler is considered a side effect of a computation. In terms of pure functions, we encode it as:
\begin{haskell}
a -> Cont r b
\end{haskell}
where \hask{Cont r} is the following functor:
\begin{haskell}
newtype Cont r a = Cont ((a -> r) -> r)
\end{haskell}
It's the responsibility of the caller of this function to provide the continuation and retrieve the result:
\begin{haskell}
runCont :: Cont r a -> (a -> r) -> r
runCont (Cont f) k = f k
\end{haskell}

This is the \hask{Functor} instance for \hask{Cont r}:
\begin{haskell}
instance Functor (Cont r) where
  -- f :: a -> b
  -- k :: b -> r
  fmap f c = Cont (\k -> runCont c (k . f))
\end{haskell}
Notice that this is a covariant functor because the type \hask{a} is in a doubly negative position.

\section{Composing Effects}

Now that we know how to make one giant leap using a function that produces both a value and a side effect, the next problem is to figure out how to decompose this leap into smaller human-sized steps. Equivalently, how do we combine two smaller steps into one larger step. 

The way effectful computations are normally composed is to use regular function composition for the values, and let the side effects combine themselves separately. 

When we translate effectful computations to pure functions, we are faced with the problem of composing two functions of the form
\begin{haskell}
f :: a -> f b
g :: b -> f c
\end{haskell}

The naive approach would be to unpack the result of the first function, pass the value to the next function, then compose the effects of both functions on the side, and finally combine them with the result of the second function. This is not always possible, even for cases that we have studied so far, much less for an arbitrary functor.

It's instructive to see how it can be done for the \hask{Maybe} functor. If the first function returns \hask{Nothing}, we have no value with which to call the second function. We have to short-circuit it, and return \hask{Nothing} as the result of composition. So the composition is possible, but it means modifying flow of control by skipping the second call based on the side effect of the first call. 

For some functors the composition of side effects is possible, for others it's not. How can we characterize those ``good'' functors?

For a functor to encode composable side effects we must at least be able to implement the following polymorphic higher-order function: 
\begin{haskell}
composeWithEffects :: Functor f => 
       (b -> f c) -> (a -> f b) -> (a -> f c)
\end{haskell}
This is very similar to regular function composition:
\begin{haskell}
(.) :: (b -> c) -> (a -> b) -> (a -> c)
\end{haskell}
so it's natural to ask if there is a category in which the former defines a composition of arrows. Let's see what more is needed to construct such a category.

Objects in this new category are the same Haskell types as before. An arrow from \hask{a} to \hask{b} is modeled as a Haskell function:
\begin{haskell}
g :: a -> f b
\end{haskell}
Our function \hask{composeWithEffects} can be used to compose such arrows. 

To have a category, we require that this composition be associative. We also need an identity arrow for every object \hask{a}. This is an arrow from \hask{a} to \hask{a}, so it corresponds to a Haskell function:
\begin{haskell}
idWithEffects :: a -> f a
\end{haskell}
It must behave like identity with respect to \hask{composeWithEffects}.

We have just defined a monad. After some renaming and rearranging, we can write it as a typeclass:
\begin{haskell}
class Functor m => Monad m where
  (<=<) :: (b -> m c) -> (a -> m b) -> (a -> m c)
  return :: a -> m a
\end{haskell}
The infix operator \hask{<=<} replaces the function \hask{composeWithEffects}. The \hask{return} function is the identity arrow in our new category. (This is not the definition of the monad you'll find in the Haskell's \hask{Prelude} but, as we'll see soon, it's equivalent to it.)

As an exercise, let's define the \hask{Monad} instance for \hask{Maybe}. The ``fish'' operator \hask{<=<} composes two functions:
\begin{haskell}
f :: a -> Maybe b
g :: b -> Maybe c
\end{haskell}
into one function of the type \hask{a -> Maybe c}. The unit of this composition, \hask{return}, encloses a value in the \hask{Just} constructor.
\begin{haskell}
instance Monad Maybe where
  g <=< f = \a -> case f a of
                    Nothing -> Nothing
                    Just b -> g b
  return = Just  
\end{haskell}

You can easily convince yourself that category laws are satisfied. In particular \hask{ return <=< g } is the same as \hask{g} and \hask{ f <=< return } is the same as \hask{f}. The proof of associativity is also pretty straightforward: If any of the functions returns \hask{Nothing}, the result is \hask{Nothing}; otherwise it's just a straightforward function composition, which is associative.

The category that we have just defined is called the \emph{Kleisli category} for the monad \hask{m}. The functions \hask{a -> m b} are called the \emph{Kleisli arrows}. They compose using \hask{<=<} and the identity arrow is called \hask{return}.

All functors from the previous section are \hask{Monad} instances. If you look at them as functors, it's hard to see any similarities between them. The thing they have in common is that they can be used to implement \emph{composable} Kleisli arrows. 

Composition is something that happens \emph{between} things. While focusing our attention on things, we often lose sight of what happen in the gaps. 

\section{Alternative Definitions}

The definition of a monad using Kleisli arrows has the advantage that the monad laws are simply the associativity and the unit laws of a category. There are two other equivalent definitions of a monad, one preferred by mathematicians, and one by programmers. 

First, let's notice that, when implementing the fish operator, we are given two functions as arguments. The only thing a function is useful for is to be applied to an argument. When we apply the first function \hask{ f :: a -> m b } we get a value of the type \hask{ m b}. At this point we would be stuck, if it weren't for the fact that \hask{m} is a functor. Functoriality lets us apply the second function \hask{ g :: b -> m c } to \hask{ m b}. Indeed the lifting of \hask{g} by \hask{m} is of the type:
\begin{haskell}
m b -> m (m c)
\end{haskell}
This is almost the result we are looking for, if we could only flatten \hask{m(m c)} to \hask{m c}. This flattening is called \hask{join}. In other words, if we are given:
\begin{haskell}
join ::  m (m a) -> m a
\end{haskell}
we can implement \hask{<=<}:
\begin{haskell}
g <=< f = \a -> join (fmap g (f a))
\end{haskell}
or, using point free notation:
\begin{haskell}
g <=< f = join . fmap g . f
\end{haskell}

Conversely, \hask{join} can be implemented in terms of \hask{<=<}:
\begin{haskell}
join = id <=< id
\end{haskell}
This may not be immediately obvious, until you realize that the rightmost \hask{id} is applided to \hask{m (m a)}, and the leftmost is applied to \hask{m a}. We interpret:
\begin{haskell}
m (m a) -> m (m a)
\end{haskell}
as an arrow in the Kleisli category that goes from \hask{ m(m a) } to \hask{m a}, and 
\begin{haskell}
m a -> m a
\end{haskell}
as a Kleisli arrow from \hask{ m a} to \hask{a}. Their Kleisli composition is again a Kleisli arrow from \hask{ m (m a)} to \hask{a}, or a function 
\begin{haskell}
m (m a) -> m a
\end{haskell}

This leads us to the equivalent definition of a monad in terms of \hask{join} and \hask{return}:
\begin{haskell}
class Functor m => Monad m where
  join :: m (m a) -> m a
  return :: a -> m a
\end{haskell}

This is still not the definition you will find in the standard Haskell \hask{Prelude}. Since the fish operator is a generalization of the dot operator, using it is equivalent to point-free programming. It lets us compose arrows without naming intermediate values. Although some consider point-free programs more elegant, most programmers find them difficult to follow. 

But function composition can be decomposed into two steps: Apply the first function, then apply the second function to the result. Explicitly naming the result may help our understanding of what's going on.

To do the same with Kleisli arrows, we have to know how to apply a Kleisli arrow to a named monadic value. The function that does that is called \emph{bind} and is written as an infix operator:
\begin{haskell}
(>>=) :: m a -> (a -> m b) -> m b
\end{haskell}
Obviously, we can implement Kleisli composition in terms of bind:

\begin{haskell}
g <=< f = \a -> (f a) >>= g
\end{haskell}

Conversely, bind can be implemented in terms of the Kleisli arrow:
\begin{haskell}
ma >>= k = (k <=< id) ma
\end{haskell}

This leads us to the following definition:
\begin{haskell}
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a 
\end{haskell}
This is almost the definition you'll find in the \hask{Prelude}, except for the additional constraint. This constraint states the fact that every instance of \hask{Monad} is also an instance of \hask{Applicative}. We will postpone the discussion of applicatives to the section on monoidal functors.

We can also implement \hask{join} using \hask{>>=}:
\begin{haskell}
join  :: (Monad m) => m (m a) -> m a
join mma =  mma >>= id
\end{haskell}
Here, \hask{id} goes from \hask{m a} to \hask{m a} or, as a Kleisli arrow, from  \hask{m a} to \hask{a}.

Interestingly, a \hask{Monad} defined using bind is automatically a functor. The lifting function for it is called \hask{liftM}
\begin{haskell}
liftM :: Monad m => (a -> b) -> (m a -> m b)
liftM f ma = ma >>= (return . f)
\end{haskell}

\section{Monad Instances}

We are now ready to define monad instances for the functors we used to describe side effects. This will allow us to compose side effects.

\subsection{Partiality}
We've already seen the version of the \hask{Maybe} monad implemented using Kleisli composition. Here's the more familiar implementation using bind:
\begin{haskell}
instance Monad Maybe where
  Nothing >>= k = Nothing
  (Just a) >>= k = k a
  return = Just
\end{haskell}

\subsection{Logging}
In order to compose functions that produce logs, we need a way to combine individual log entries. This is why the writer monad:
\begin{haskell}
newtype Writer w a = Writer (a, w)
\end{haskell}
requires the type of the log to be a monoid. This allows us to append logs and to create an empty log.
\begin{haskell}
instance Monoid w => Monad (Writer w) where
  (Writer (a, w)) >>= k = let (Writer (b, w')) = k a
                          in Writer (b, mappend w w')
  return a = Writer (a, mempty)
\end{haskell}
The \hask{let} clause is used for introducing local bindings. Here, the result of applying \hask{k} is pattern matched, and the local variables \hask{b} and \hask{w'} are initialized. The \hask{let}/\hask{in} construct is an expression whose value is given by the content of the \hask{in} clause.

\subsection{Environment}

The reader monad is a thin encapsulation of a function from the environment to the relevant return type:
\begin{haskell}
newtype Reader e a = Reader (e -> a)
\end{haskell}
Here's the \hask{Monad} instance:
\begin{haskell}
instance Monad (Reader e) where
  ma >>= k = Reader (\e -> let a = runReader rd e
                           in runReader (k a) e)
  return a = Reader (\e -> a)
\end{haskell}
The implementation of bind for the reader monad creates a function that takes the environment as its argument. This environment is used twice, first to run \hask{ma} to get the value of \hask{a}, and then to evaluate the value produced by running \hask{k a}.

The implementation of \hask{return} ignores the environment.

\begin{exercise}
Define the \hask{Functor} and the \hask{Monad} instance for the following data type:
\begin{haskell}
newtype E e a = E (e -> Maybe a)
\end{haskell}
Hint: You may use this handy function:
\begin{haskell}
runE :: E e a -> e -> Maybe a
runE (E f) e = f e
\end{haskell}
\end{exercise}


\subsection{State}
Like reader, the state monad is also a function type:
\begin{haskell}
newtype State s a = State (s -> (a, s))
\end{haskell}
Its bind is similar, except that the result of \hask{k} acting on  \hask{a} is now run with the modified state \hask{s'}.
\begin{haskell}
instance Monad (State s) where
  st >>= k = State (\s -> let (a, s') = runState st s
                          in runState (k a) s')
                          
  return a = State (\s -> (a, s))
\end{haskell}

Applying bind to identity gives us the definition of \hask{join}:
\begin{haskell}
join :: State s (State s a) -> State s a
join mma = State (\s -> let (ma, s') = runState mma s
                        in runState ma s')
\end{haskell}
Notice that we are essentially passing the result of the first \hask{runState} to the second \hask{runState}, except that we have to uncurry the second one so it can accept a pair:
                             
\begin{haskell}
join mma = State (\s -> (uncurry runState) (runState mma s))
\end{haskell}
In this form, it's easy to convert it to point-free notation:
\begin{haskell}
join mma = State (uncurry runState . runState mma)
\end{haskell}

There are two basic Kleisli arrows (the first one, conceptually, coming from the terminal object \hask{()}) using which we can construct an arbitrary stateful computation. The first one retrieves the current state:
\begin{haskell}
get :: State s s
get = State (\s -> (s, s))
\end{haskell}
and the second one modifies it:
\begin{haskell}
set :: s -> State s ()
set s = State (\_ -> ((), s))
\end{haskell}

\subsection{Nondeterminism}

For the list monad, let's consider how we could implement \hask{join}. It must turn a list of lists into a single list. This can be done by concatenating all the inner lists using the library function \hask{concat}. From there, we can derive the implementation of bind.
\begin{haskell}
instance Monad [] where
  as >>= k = concat (fmap k as)
  return a = [a]
\end{haskell}
\hask{return} constructs a singleton list.

What in imperative languages is done using nested loops we can do in Haskell using the list monad. Think of \hask{as} as aggregating the result of running the inner loop and \hask{k} as the code that runs in the outer loop. 

In many ways, Haskell's list behaves more like what is called an iterator or a generator in imperative languages. Because of laziness, the elements of the list are rarely stored in memory all at once. You may also think of a list as a coroutine that produces elements of a sequence on demand.

\subsection{Continuation}

The implementation of bind for the continuation monad:

\begin{haskell}
newtype Cont r a = Cont ((a -> r) -> r)
\end{haskell}
requires some backward thinking, because of the inversion of control. 

The result of bind is supposed to be a function that takes, as an argument, a continuation \hask{k} of the type:
\begin{haskell}
k :: b -> r
\end{haskell}
We have to put together such a function given the two ingredients at our disposal: 
\begin{haskell}
ma :: Cont r a
fk :: a -> Cont r b
\end{haskell}
We can run \hask{ma} as long as we can give it a continuation that accepts an \hask{a}. We can build such a continuation: given an \hask{a} it will call \hask{fk}, which returns a \hask{b}-expecting continuation. That's exactly the continuation \hask{k} we have at our disposal:
\begin{haskell}
instance Monad (Cont r) where
  ma >>= fk = Cont (\k -> runCont ma (\a -> runCont (fk a) k))
  return a = Cont (\k -> k a)
\end{haskell}
As I mentioned earlier, composing continuations is not for the faint of heart. However, it has to be implemented only once, in the definition of the continuation monad. From there on, the \hask{do} notation makes it really easy.

\subsection{Input/Output}

The \hask{IO} monad's implementation is baked into the language. The basic I/O primitives are available through the library. They are either in the form of Kleisli arrows, or \hask{IO} objects (conceptually, Kleisli arrows from the terminal object \hask{()}). For instance, the following object contains a command to read a line from the standard input:
\begin{haskell}
getLine :: IO String
\end{haskell}
There is no way to extract the string from it, since it's not there yet; but the program can process it through a series of Kleisli arrows. For instance, if you want to execute different code depending on the string stored in the \hask{IO} object, you bind it to a Kleisli arrow that takes a string as input and produces a more complex \hask{IO} action, and so on. 

The \hask{IO} monad is the ultimate procrastinator: the composition of its Kleisli arrows piles up task after task to be executed later.

To output a string followed by a newline, you can use this Kleisli arrow:
\begin{haskell}
putStrLn :: String -> IO ()
\end{haskell}
Combining the two, you can construct a simple \hask{main} object:
\begin{haskell}
main :: IO ()
main = getLine >>= putStrLn
\end{haskell}
which echos a string you type.

\section{Do Notation}

It's worth repeating that the purpose of monads in programming is to let us decompose one big Kleisli arrow into multiple smaller ones. 

This can be either done directly, in a point-free style, using Kleisli composition \hask{<=<}; or by naming intermediate values and binding them to Kleisli arrows using \hask{>>=}. 

Some Kleisli arrows are defined in libraries, others are reusable enough to warrant out-of-line implementation but, in practice, the majority are implemented as single-shot inline lambdas.

Here's a simple example:
\begin{haskell}
main :: IO ()
main = 
  getLine >>= \s1 ->
    getLine >>= \s2 ->
      putStrLn ("Hello " ++ s1 ++ " " ++ s2)
\end{haskell}
which uses an ad-hoc Kleisli arrow of the type \hask{String->IO ()} defined by the lambda expression:
\begin{haskell}
\s1 ->
    getLine >>= \s2 ->
      putStrLn ("Hello " ++ s1 ++ " " ++ s2)
\end{haskell}
The body of this lambda is further decomposed using another ad-hoc Kleisli arrow:
\begin{haskell}
\s2 -> putStrLn ("Hello " ++ s1 ++ " " ++ s2)
\end{haskell}

Such constructs are so common that there is special syntax called the \hask{do} notation that avoids a lot of boilerplate. The above code can be written as:
\begin{haskell}
main = do
  s1 <- getLine
  s2 <- getLine
  putStrLn ("Hello " ++ s1 ++ " " ++ s2)
\end{haskell}
The compiler will automatically convert it to a series of nested lambdas. The line \hask{ s1<-getLine } can be read as: ``\hask{s1} \emph{gets} the result of \hask{getLine}.''

Here's another example: a function that uses the list monad to generate all possible pairs of elements taken from two lists.
\begin{haskell}
pairs :: [a] -> [b] -> [(a, b)]
pairs as bs = do
  a <- as
  b <- bs
  return (a, b)
\end{haskell}
Notice that the last line in a \hask{do} block must return a monadic value---here this is accomplished using \hask{return}.


As mentioned before, the \hask{do} notation makes an easy task of otherwise very cumbersome composition of continuations.

Most imperative languages lack the abstraction power to generically define a monad and instead they attempt to hard-code some of the common monads. For instance, they implement exceptions as an alternative to the \hask{Either} monad, or concurrent tasks as an alternative to the continuation monad. Some, like C++, introduce coroutines that mimic Haskell's \hask{do} notation. 

\begin{exercise}
Implement the following function that works for any monad:
\begin{haskell}
ap :: Monad m => m (a -> b) -> m a -> m b
\end{haskell}
Hint: Use \hask{do} notation to extract the function and the argument. Use \hask{return} to return the result.
\end{exercise}

\begin{exercise}
Rewrite the \hask{pairs} function using the bind operators and lambdas.
\end{exercise}

\section{Monads Categorically}

In category theory monads first arose in the study of algebras. In particular, the bind operator can be used to implement the very important operation of substitution. 

\subsection{Substitution}

Consider this simple expression type parameterized by the type that we will use for naming variables:
\begin{haskell}
data Ex x = Val Int 
          | Var x 
          | Plus (Ex x) (Ex x) 
 deriving (Functor, Show)
\end{haskell}
Using this type we can, for instance, construct an expression $(2 + a) + b$:
\begin{haskell}
ex :: Ex Char
ex = Plus (Plus (Val 2) (Var 'a')) (Var 'b')
\end{haskell}
We can implement the \hask{Monad} instance for it:
\begin{haskell}
instance Monad Ex where
  Val n >>= k = Val n
  Var x >>= k = k x
  Plus e1 e2 >>= k = 
    let x = e1 >>= k
        y = e2 >>= k
    in (Plus x y)
    
  return x = Var x 
\end{haskell}

Now suppose that you want to make a substitution by replacing $a$ with $x_1 + 2$ and $b$ with $x_2$ (for simplicity, let's not worry about other letters of the alphabet). This substitution is represented by the Kleisli arrow \hask{sub} (as you can see, we were even able to change the type of variable names from \hask{Char} to \hask{String}):
\begin{haskell}
sub :: Char -> Ex String
sub 'a' = Plus (Var "x1") (Val 2)
sub 'b' = Var "x2"
\end{haskell}
When we bind it to \hask{ex}
\begin{haskell}
ex' :: Ex String
ex' = ex >>= sub
\end{haskell}
we get, as expected, a tree corresponding to $(2 + (x_1 + 2)) + x_2$.

\subsection{Monad as a monoid}

Let's analyze the definition of a monad that uses \hask{join}:
\begin{haskell}
class Functor m => Monad m where
  join :: m (m a) -> m a
  return :: a -> m a
\end{haskell}
We have an endofunctor \hask{m} and two polymorphic functions. 

In category theory, the functor that defines the monad is traditionally denoted by $T$ (probably because monads were initially called ``triples''). The two polymorphic functions become natural transformations. The first one, corresponding to \hask{join}, maps the ``square'' of $T$---or a composition of $T$ with itself---to $T$:
\[ \mu \colon T \circ T \to T \]
(Of course, only \emph{endo}-functors can be squared this way.) 

The second maps the identity functor to $T$:
\[ \eta \colon Id \to T \]

Compare this with our earlier definition of a monoid in a monoidal category:
\[ \mu \colon M \otimes M \to M \]
\[ \eta \colon I \to M \]
The similarity is striking. This is why we often call the natural transformation $\mu$ \emph{monadic multiplication}. But in what category can the composition of functors be considered a tensor product? 

Enter the category of endofunctors. Objects in this category are endofunctors and arrows are natural transformations. 

But there's more structure in that category. Any two endofunctors can be composed, so maybe composition could serve as a tensor product? After all, the only condition we impose on a tensor product is that it's functorial in both arguments. That is, given a pair of arrows:
 \[ \alpha \colon T \to T'\]
 \[ \beta \colon S \to S' \]
 we can lift it to the mapping of tensor products:
 \[ \alpha \otimes \beta \colon T \otimes S \to T' \otimes S' \]
 
 In the category of endofunctors, the arrows are natural transformations so, if we replace $\otimes$ with $\circ$, the lifting would be a mapping:
\[ \alpha \circ \beta \colon T \circ T' \to S \circ S' \]
But this is just horizontal composition of natural transformations (now you understand why it's denoted by a circle).

The unit object in this monoidal category is the identity endofunctor, and unit laws are satisfied ``on the nose,'' meaning
\[ \text{Id} \circ T = T = T \circ \text{Id}\]
We don't need any unitors---or, for that matter, associators---since functor composition is automatically associative. 

A monoidal category in which unit and associativity laws are equalities is called a \index{strict monoidal category}\emph{strict} monoidal category.

Notice, however, that composition is not symmetric, so this is not a symmetric monoidal category.

So, all said, a monad is a monoid in the monoidal category of endofunctors. 

A monad $(T, \eta, \mu)$ consists of an object in the category of endofunctors---meaning an endofunctor $T$; and two arrows---meaning natural transformations:
\[ \eta \colon \text{Id} \to T \]
\[ \mu \colon T \circ T \to T \]
For this to be a monoid, these arrows must satisfy monoidal laws. Here are the unit laws (the unitors here are strict equalities):
\[
 \begin{tikzcd}
\text{Id} \circ T
 \arrow[rr, "\eta \circ T"]
 \arrow[rrd, "="']
& & T \circ T
 \arrow[d, "\mu"]
&& T \circ \text{Id}
 \arrow[ll, "T \circ \eta"']
 \arrow[lld, "="]
 \\
 && T
  \end{tikzcd}
\]
and this is the associativity law:
\[
 \begin{tikzcd}
 (T \circ T) \circ T 
 \arrow[rr, "="]
 \arrow[d, "\mu \circ T"]
 &&
 T \circ (T \circ T)
 \arrow[d, "T \circ \mu"]
 \\
 T \circ T 
 \arrow[dr, "\mu"]
& & T \circ T
 \arrow[dl, "\mu"']
 \\
&  T
 \end{tikzcd}
\]
We used the whiskering notation for horizontal composition of $\mu \circ T$ and $T \circ \mu$.

These are the monad laws in terms of $\mu$ and $\eta$. They can be directly translated to the laws for \hask{join} and \hask{return}. They are also equivalent to the laws of the Kleisli category built from arrows $A \to T B$.

\section{Monoidal Functors}

We've seen several examples of monoidal cateogries. Such categories are equipped with some kind of binary operation, e.g., a cartesian product, a sum, composition (in the category of endofunctors), etc. They also have a special object that serves as a unit with respect to this binary operation. Unit and associativity laws are satisfied either on the nose (in strict monoidal categories) or up to isomorphism.

Every time we have more than one instance of some structure, we may ask ourselves the question: is there a whole category of such things? In this case: do monoidal categories form their own category? For that we have to define arrows between monoidal categories.

A \emph{monoidal functor} $F$ from a monoidal category $\mathcal{C}$ to another monoidal category $\mathcal{D}$ maps tensor product to tensor product and unit to unit---all up to isomorphism:
\begin{align*}
F A \otimes F B &\cong F (A \otimes B) \\
I &\cong F I 
\end{align*}
Here, on the left-hand side we have the tensor product and the unit in the target category, and on the right their counterparts in the source category. 

If the two monoidal categories in question are not strict, that is the unit and associativity laws are satisfied only up to isomorphism, there are additional coherency conditions that ensure that unitors are mapped to unitors and associators are mapped to associators.

The category of monoidal categories with monoidal functors as arrows is called $\mathbf{MonCat}$. In fact it's a 2-category, since one can define structure-preserving natural transformations between monoidal functors.

\subsection{Lax monoidal functors}

One of the perks of monoidal categories is that they allow us to define monoids. You can easily convince yourself that monoidal functors map monoids to monoids. It turns out that we don't need the whole power of monoidal functors to accomplish this task. Let's consider what are the minimal requirements for a functor to map a monoid to a monoid. 

Let's start with a monoid $(M, \mu, \eta)$ in the monoidal category $(\mathcal{C}, \otimes, I)$. We have a functor $F$ that maps $M$ to $F M$ and we want $F M$ to be a monoid in the target monoidal category $(\mathcal{D}, \otimes_{\mathcal{D}}, I_{\mathcal{D}})$. For that we need to find two morphisms:
\begin{align*}
\eta' &\colon I_{\mathcal{D}} \to F M \\
 \mu' &\colon F M \otimes_{\mathcal{D}} F M \to F M 
\end{align*}
satisfying monoidal laws.

We do have at our disposal the liftings of the original morphisms:
\begin{align*}
 F \eta &\colon F I \to F M \\
 F \mu &\colon F (M \otimes M) \to F M
\end{align*}

What we are missing in order to implement $\eta'$ and $\mu'$ are two additional arrows 
\begin{align*}
I_{\mathcal{D}} &\to F I\\
 F M \otimes_{\mathcal{D}} F M &\to F (M \otimes M)
 \end{align*}
A monoidal functor would provide such arrows as halves of the defining isomorphisms, but for what we're trying it accomplish, we don't need the other halves. All we need is a weaker notion of a lax monoidal functor. 

A \emph{lax monoidal functor} is a functor equipped with a one-way morphism $\phi_I$ and a natural transformation whose components are $\phi_{A B}$:
\begin{align*}
\phi_I &\colon I_{\mathcal{D}} \to F I \\
\phi_{A B} &\colon F A \otimes_{\mathcal{D}} F B \to F (A \otimes B)
\end{align*}
satisfying the appropriate untiality and associativity conditions.

\subsection{Lax monoidal functors in Haskell}

\begin{haskell}
class Monoidal f where
  unit  :: f ()
  (>*<) :: f x -> f y -> f (x, y)
\end{haskell}

\subsection{Applicative functors}

\subsection{Functorial strength}

strong monads


\end{document}