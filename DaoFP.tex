\documentclass[11pt, book]{memoir}

\settrims{0pt}{0pt} % page and stock same size
\settypeblocksize{*}{34.5pc}{*} % {height}{width}{ratio}
\setlrmargins{*}{*}{1} % {spine}{edge}{ratio}
\setulmarginsandblock{1in}{1in}{*} % height of typeblock computed
\setheadfoot{\onelineskip}{2\onelineskip} % {headheight}{footskip}
\setheaderspaces{*}{1.5\onelineskip}{*} % {headdrop}{headsep}{ratio}
\checkandfixthelayout

\chapterstyle{bianchi}
\newcommand{\titlefont}{\normalfont\Huge\bfseries}
\renewcommand{\chaptitlefont}{\titlefont}

\usepackage{subfiles}
\usepackage{makeidx}

\usepackage{amsfonts}
\usepackage{amssymb}  
\usepackage{amsthm} 
\usepackage{amsmath} 
\usepackage{tikz-cd}
\usetikzlibrary{backgrounds}
\usepackage{float}
\usepackage{xcolor}

\newtheorem{exercise}{Exercise}[section]
\newcommand{\exinline}[1]{(\refstepcounter{exercise}Exercise~\theexercise\label{#1})}

\usepackage{minted}
\usepackage{etoolbox}

\usepackage{hyperref}
\hypersetup{
  colorlinks,
  linkcolor={red!40!black},
  citecolor={red!40!black},
  urlcolor={blue!40!black}
}

\newcommand{\cat}[1]{\mathcal{#1}}%a generic category
\newcommand{\Cat}[1]{\mathbf{#1}}%a named category
\newcommand{\Set}{\Cat{Set}}

\newcommand{\hask}[1]{\mintinline{Haskell}{#1}}
\newenvironment{haskell}
  {\VerbatimEnvironment
  	%\begin{minted}[escapeinside=??, mathescape=true, frame=single, framesep=5pt, tabsize=1, bgcolor=black!5]{Haskell}}
  	\begin{minted}[escapeinside=??, mathescape=true, tabsize=1, bgcolor=black!3, xleftmargin=3pt ]{Haskell}}
  {\end{minted}}
\makeatletter
% replace \medskip before and after the box with nothing, i.e., remove it
\patchcmd{\minted@colorbg}{\medskip}{}{}{}
\patchcmd{\endminted@colorbg}{\medskip}{}{}{}
\makeatother

\makeindex

\begin{document}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}
\frontmatter

\title{\huge The Dao of Functional Programming}
\author{\Large Bartosz Milewski }

\date{\vfill (Last updated: \today)}

\maketitle

\tableofcontents*

\clearpage

\section{Preface}

Most programming texts, following Brian Kernighan, start with "Hello World!". It's natural to want to get the immediate gratification of making the computer do your bidding and print these famous words. But the real mastery of computer programming goes deeper than that, and rushing into it may only give you a false feeling of power, when in reality you're just parroting the masters. If your ambition is just to learn a useful, well-paid skill then, by all means, write your "Hello World!" program. There are tons of books and courses that will teach you how to write code in any language of your choice. However, if you really want to get to the essence of programming, you need to be patient and persistent.

Category theory is the branch of mathematics that provides the abstractions that accord with the practical experience of programming. Paraphrasing von Clausewitz: Programming is merely the continuation of mathematics with other means. A lot of complex ideas of category theory become obvious to programmers when explained in terms of data types and functions. In this sense, category theory might be more accessible to programmers than it is to professional mathematicians.

When faced with a new categorical concepts I would often look them up on Wikipedia or nLab, or re-read a chapter from Mac Lane or Kelly. These are great sources, but they require up front some familiarity with the topics and the ability to fill in the gaps. One of the goals of this book is to provide the bootstrap and prepare the reader to continue studying.

There is a lot of folklore knowledge in category theory and in computer science that is nowhere to be found in the literature. It's very difficult to acquire useful intuitions when going through dry definitions and theorems. I tried, as much as possible, to provide the missing intuitions and explain not only the whats but also the whys.

\subsection{Conventions}

I tried to keep the notation coherent throughout the book. It's based loosely on the prevailing style in nLab.

In particular, I decided to use lowercase letters like $a$ or $b$ for objects in a category and uppercase names like $S$ for sets, even though sets are objects in the category of sets and functions. Generic categories have names like $\cat C$ or $\cat D$, whereas specific categories have names like $\Set$ or $\Cat{Cat}$. 

Programming examples are written in Haskell. Although this is not a Haskell manual, the introduction of language constructs is gradual enough to help the reader navigate the code. The fact that Haskell syntax is often based on mathematical notation is an additional advantage. Program fragments are written in the following format:
\begin{haskell}
apply :: (a -> b, a) -> b
apply (f, x) = f x
\end{haskell}

\mainmatter

\subfile{1-CleanSlate}
\subfile{2-Composition}
\subfile{3-Isomorphism}
\subfile{4-SumTypes}
\subfile{5-ProductTypes}
\subfile{6-FunctionTypes}
\subfile{7-Recursion}
\subfile{8-Functors}
\subfile{9-NaturalTransformations}
\subfile{10-Adjunctions}
\subfile{11-DependentTypes}
\subfile{12-Algebras}
\subfile{13-Coalgebras}
\subfile{14-Monads}
\subfile{15-MonadsAdjunctions}
\subfile{16-Comonads}
\subfile{17-Ends}
\subfile{18-Tambara}
\subfile{19-Kan}
\subfile{20-Enrichment}

\printindex

\end{document}