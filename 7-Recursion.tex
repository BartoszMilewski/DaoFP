\documentclass[DaoFP]{subfiles}
\begin{document}
\setcounter{chapter}{6}

\chapter{Recursion}

When you step between two mirrors, you see your reflection, the reflection of your reflection, the reflection of that reflection, and so on. Each reflection is defined in terms of the previous reflection, but together they produce infinity.

Recursion is a decomposition pattern that splits a single task into many steps, the number of which is unbounded.  

Recursion is based on suspension of disbelief. You are faced with a task that may take arbitrarily many steps. You tentatively assume that you know how to solve it. Then you ask the question: "How would I make the last step if I had the solution to everything \emph{but} the last step?"

\section{Natural Numbers}

An object of natural numbers $N$ does not contain numbers. Objects have no internal structure. Structure is defined by arrows. 

We can use an arrow from the terminal object to define one special element. By convention, we'll call this arrow $Z$ for ``zero.''
\[ Z \colon 1 \to N \]
But we have to be able to define infinitely many arrows to account for the fact that, for every natural number, there is another number that is one larger than it. 

We can formalize this statement by saying: Suppose that we know how to create a natural number $n \colon 1 \to N$. How do we make the next step, the step that will point us to the next number---the successor? 

This next step doesn't have to be more complex than just post-composing $n$ with an arrow that loops back to $N$. This arrow can't be the identity, because we want the successor of a number to be different from the original. But a single such arrow, which we'll call $S$  for ``successor'' will suffice. 

The element corresponding to the successor of $n$ is given by the composition:
\[ 1 \xrightarrow{n} N \xrightarrow{S} N\]
We often draw the same object multiple times in a single diagram if we want to straighten the looping arrows.

In particular, we can define $One$ as the successor of $Z$:
\[
 \begin{tikzcd}
 1
 \arrow[rr, bend left, "One"]
 \arrow[r, "Z"]
 &N
  \arrow[r, "S"]
&N
  \end{tikzcd}
\]
and $Two$ as the successor of the successor of $Z$
\[
 \begin{tikzcd}
 1
 \arrow[rrr, bend left, "Two"]
 \arrow[r, "Z"]
 &N
  \arrow[r, "S"]
&N
  \arrow[r, "S"]
 &N
 \end{tikzcd}
\]
and so on.

\subsection{Introduction Rules}

The two arrows, $Z$ and $S$, serve as the introduction rules for the natural number object $N$. The twist is that one of them is recursive: $S$ uses $N$ as its source as well as the target.

\[
 \begin{tikzcd}
 1
 \arrow[r, "Z"]
 &N
 \arrow[loop, "S"']
 \end{tikzcd}
\]
The introduction rules translate directly to Haskell


\begin{haskell}
data Nat where
  Z :: Nat
  S :: Nat -> Nat
\end{haskell}
They can be used (tediously) to define arbitrary natural numbers; for instance:

\begin{haskell}
zero, one, two :: Nat
zero = Z
one  = S zero
two  = S one
\end{haskell}

This definition of natural number type is not very useful in practice. However, it's often used in defining type-level naturals, where each number is its own type. You may encounter them under the name of \emph{Peano arithmetic}.

\subsection{Elimination Rules}

The fact that the introduction rules are recursive complicates the matters slightly when it comes to defining the elimination rules. We will follow the pattern from previous chapters of first assuming that we are given a mapping out of $N$:
\[ h \colon N \to A \]
and see what we can deduce from there. 

Previously, we were immediately able to decompose such an $h$ into simpler mappings (pairs of mappings for sum and product, a mapping out of a product for the exponential). 

The introduction rules for $N$ look similar to those for the sum, so we would expect that $h$ could be split into two arrows corresponding to two introduction rules. And, indeed, we can easily get the first one by composing $h \circ Z$. This is an arrow that picks an element of $A$. We call $init$:
\[\text{init} \colon 1 \to A \]
But there is no obvious way to find the second one. 


Let's try to plug $h$ into the definition of $N$.
\[
 \begin{tikzcd}
 1
 \arrow[r, "Z"]
 \arrow[rd, "\text{init}"']
 &N
  \arrow[r, "S"]
\arrow[d, dashed, "h"]
&N
  \arrow[r, "S"]
\arrow[d, dashed, "h"]
&N
\arrow[d, dashed, "h"]
& ...
\\
& A
& A
& A
  \end{tikzcd}
\]

The intuition is that an arrow from $N$ to $A$ represents a \emph{sequence} of elements of $A$. The zeroth element is given by $a_0=init$. The next element is
\[a_1 = h \circ S \circ Z \]
followed by
\[a_2 = h \circ S \circ S \circ Z \]
and so on.

We have replaced one arrow $h$ with infinitely many arrows $a_n$. Granted, the new arrows are simpler, since they represent elements of $A$, but there are infinitely many of them. 

The problem is that, no matter how you look at it, an arbitrary mapping out of $N$ contains infinite amount of information.

We have to drastically simplify the problem. Since we used a single arrow $S$ to generate all natural numbers, we can try to use a single arrow $A \to A$ to generate all the elements $a_n$. We'll call this arrow $step$:
\[
 \begin{tikzcd}
 1
 \arrow[r, "Z"]
 \arrow[rd, "\text{init}"']
 &N
  \arrow[r, "S"]
\arrow[d, dashed, "h"]
&N
\arrow[d, dashed, "h"]
\\
& A
\arrow[r, "\text{step}"]
& A
  \end{tikzcd}
\]
The mappings out of $N$ that are generated by such pairs, $init$ and $step$, are called \emph{recursive}. 

We use the above diagram as the elimination rule. Every recursive mapping out of $N$ is defined by a pair $init$ and $step$. 

Not all mappings are recursive (in fact, very few are), but recursive mappings are enough to define the object of natural numbers. 

This means that the evaluation rule cannot be formulated for an arbitrary arrow $h \colon N \to A$, only for recursive arrows that were defined using a pair $(init, step)$. The arrow $init$ can be simply recovered by composing $h \circ Z$. The arrow $step$ is a solution to the equation:
\[ step \circ h = h \circ S \]
If $h$ was defined using some $init$ and $step$, then this equation obviously has a solution. 

The important part is that we demand that this solution be unique. Two different pairs $(init, step)$ cannot generate the same recursive function $h$.  Only if this uniqueness condition is satisfied, can we call $N$ the natural number object. 

\subsection{In Programming}

The elimination rule can be implemented as a recursive function in Haskell:

\begin{haskell}
rec :: a -> (a -> a) -> (Nat -> a)
rec init step = \n ->
  case n of
    Z     -> init
    (S m) -> step (rec init step m)
\end{haskell}

This single function is enough to implement all recursive functions of natural numbers. For instance, this is how we could implement addition:

\begin{haskell}
plus :: Nat -> Nat -> Nat
plus n = rec init step
  where
    init = n
    step = S
\end{haskell}
This function takes \hask{n} as an argument and produces a function (a closure) that takes another number and adds  \hask{n} to it. 

In practice, programmers prefer to implement recursion directly---an approach that is equivalent to inlining the recursor \hask{rec}. The following implementation is arguably easier to analyze:
\begin{haskell}
plus n m = case m of
  Z -> n
  (S k) -> S (plus k n)
\end{haskell}
It can be read as: If \hask{m} is zero then the result is \hask{n}. Otherwise, if \hask{m} is a successor of some \hask{k} then the result is the successor of  \hask{k + n}. This is exactly the same as saying that \hask{init = n} and \hask{step = S}.

In imperative languages recursion is usually replaced by equivalent looping constructs. 

\begin{exercise}
Implement a curried version of addition as a mapping out of $N$ into the function object $N^N$. Hint: use these types in the recursor:
\begin{haskell}
    init :: Nat -> Nat
    step :: (Nat -> Nat) -> (Nat -> Nat)
\end{haskell}

\end{exercise}


\subsection{Induction}

The elimination pattern for the natural number object is reminiscent of proof by induction. The arrow $init$ looks like the proof of the base case, and $step$ looks like the induction step. Except that, in the propositions as types interpretation, we would interpret the target $A$ as a single proposition. 

The principle of induction corresponds to the elimination pattern that involves \emph{dependent types}. Instead of a single type $A$, it uses a whole family of types parameterized by natural numbers $A(n)$. The $init$ arrow is an element of $A(Z)$, and $step$ is a dependent function that maps $A(n)$ to $A(S\, n)$.

\section{Lists}

\begin{haskell}
data List a where
  Nil :: List a
  Cons :: a -> List a -> List a
\end{haskell}


\section{notes}

lists of unit as nats

\begin{exercise}
\end{exercise}
\begin{haskell}
\end{haskell}



\end{document}