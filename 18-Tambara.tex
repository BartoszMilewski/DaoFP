\documentclass[DaoFP]{subfiles}
\begin{document}
\setcounter{chapter}{17}

\chapter{Tambara Modules}

It's not often that an obscure corner of category theory gains sudden prominence in programming. Tambara modules got a new lease on life in their application to profunctor optics. They provide a clever solution to the problem of composing optics. We've seen that, in the case of lenses, the getters compose nicely using function composition, but the composition of setters involves some shenanigans. The existential representation doesn't help much. The profunctor representation, on the other hand, makes composition a snap. 

The situation is somewhat analogous to the problem of composing geometric transformations in graphics programming. For instance, if you try to compose two rotations around two different axes, the formula for the new axis and the angle is quite complicated. But if you represent rotations as matrices, you can use matrix multiplication; or, if you represent them as quaternions, you can use quaternion multiplication. Profunctor representation lets you compose optics using straightforward function composition.

\section{Tannakian Reconstruction}

\subsection{Monoids and their Representations}

The theory or representations is a science in itself. Here, we'll approach it from the categorical perspective. Instead of groups, we'll consider monoids. A monoid can be defined as a special object in a monoidal category, but it can also be thought of as a single-object category $\cat M$. If we call this object $*$, the hom-set $\cat M( *, *)$ contains all the information we need. 

Monoidal product is simply the composition of morphisms. By the laws of a category, it's associative and unital---the identity morphism serving as the monoidal unit.

In this sense, every single-object category is automatically a monoid and all monoids can be made into single-object categories. 

For instance, a monoid of whole numbers with addition can be thought of as a category with a single object $*$ and a morphism for every number. To compose two such morphisms, you add their numbers, as in the example below:
\[
 \begin{tikzcd}
  *
  \arrow[r, bend left, "2"]
  \arrow[rr, bend right, "5"']
 & *
 \arrow[r, bend left, "3"]
 & *
  \end{tikzcd}
\]
The morphism corresponding to zero is automatically the identity morphism. 

We can represent a monoid on a set. Such a representation is a functor $F$ from $\cat M$ to $\Set$. Such a functor maps the single object $*$ to some set $S$, and it maps the hom-set $\cat M(*, *)$ to a set of functions $S \to S$. By functor laws, it maps identity to identity and composition to composition, so it preserves the structure of the monoid. 

If the functor is fully faithful, its image contains exactly the same information as the monoid and nothing more. But, in general, functors cheat. The hom-set $\Set (S, S)$ may contain some other functions that are not in the image of $\cat M(*, *)$; and multiple morphisms can be mapped to a single function. 

In the extreme, the whole hom-set $\cat M(*, *)$ may be mapped to the identity morphism $id_S$. So, just by looking at the set $S$---the image of $*$ under the functor $F$---we cannot dream of reconstructing the original monoid.

Not all is lost, though, if we are allowed to look at all the representations of a given monoid simultaneously. Such representations form a functor category $[\cat M, \Set]$, a.k.a. the co-presheaf category. Arrows in this category are natural transformations. 

Since the source category $\cat M$ contains only one object, naturality conditions take a particularly simple form. A natural transformation $\alpha \colon F \to G$ has only one component, a function $\alpha \colon F * \to G *$. Given a morphism $m \colon * \to *$, the naturality square reads:

\[
 \begin{tikzcd}
 F *
 \arrow[r, "\alpha"]
 \arrow[d, "F m"]
 & G *
  \arrow[d, "G m"]
\\
 F *
 \arrow[r, "\alpha"]
 & G *
 \end{tikzcd}
\]
It's a relationship between three functions acting on two sets:
\[
 \begin{tikzcd}
 F *
  \arrow[loop, "F m"']
  \arrow[rr, bend right, "\alpha"']
 && G *
  \arrow[loop, "G m"']
  \end{tikzcd}
\]
The naturality condition tells us that:
\[ G m \circ \alpha = \alpha \circ F m \]

In other words, if you pick an element $x \in F *$, you can map it to $G *$ using $\alpha$ and then apply the transformation corresponding to $m$; or you can first apply the thansformation $F m$ and then map the result using $\alpha$. The result is the same in both cases.

Such functions are called \index{equivariant function}\emph{equivariant}. We often call $F m$ the \emph{action} of $m$ on the set $F *$. An equivariant function maps an action on one set to its corresponding action on another set. 

\subsection{Tannakian reconstruction of a monoid}

How much information do we need to reconstruct a monoid from its representations? Just looking at the sets is definitely not enough, since any monoid can be represented on any set. But if we include structure-preserving functions between these sets, we might have a chance. 

Consider a set of functions $\Set(F *, F *)$ for a given functor $F \colon \cat M \to \Set$. At least some of these are the actions of the monoid, $F m$. If we look at the ``neighboring'' set $G *$ and its set of functions  $\Set(G *, G *)$ we'll find there the corresponding actions $G m$. An equivariant function, that is a natural transformation in $[\cat M, \Set]$, will map these actions. It will map other morphisms as well.

Imagine creating a gigantic tuple by taking one function from each of the sets $\Set (F *, F *)$, for all functors $F\colon \cat M \to \Set$. Moreover, we want the elements of the tuple to be correlated. If we pick $g \in  \Set (G*, G *)$ and  $h \in  \Set (H*,  H*)$ and there is a natural transformation (equivariant function) $\alpha$ between the two functors $G$ and $H$, we want the two function to be related:
\[ \alpha \circ g = h \circ \alpha \]
or, pictorially:
\[
 \begin{tikzcd}
 G *
  \arrow[loop, "g"']
  \arrow[rr, bend right, "\alpha"']
 && H *
  \arrow[loop, "h"']
  \end{tikzcd}
\]
Notice that this will guarantee that actions are mapped to corresponding actions if, for instance, $g = G m$ and $h = H m$. 

Such tuples are exactly the elements of the end:
\[ \int_F \Set(F *, F *) \]
whose wedge condition provides the constraints we are looking for. 

\[
 \begin{tikzcd}
 & \int_F \Set (F *, F *)
 \arrow[dl, "\pi_G"']
 \arrow[dr, "\pi_H"]
 \\
 \Set(G *, G *)
 \arrow[dr, "{\Set(id, \alpha)}"']
 && \Set (H *, H *)
  \arrow[dl, "{\Set (\alpha, id)}"]
\\
 & \Set (G *, H *)
 \end{tikzcd}
\]

Notice that this is the end over the whole functor category $[\cat M, \Set ]$, so the wedge condition relates the entries that are connected by natural transformations. In this case, natural transformations are equivariant functions. The profunctor under the end is given by:
\[ P \langle G, H \rangle = \Set (G *, H *) \]
It is a functor:
\[ P \colon [\cat M, \Set]^{op} \times [\cat M, \Set] \to \Set \]
Its action on morphisms (natural transformations) is:
\[ P \langle \alpha, \beta \rangle = \beta \circ - \circ \alpha \]
If we pick $f$ to be the element of $\Set (G*, G*)$ and $g$ to be the element of $\Set (H*, H*)$, the wedge condition indeed becomes:
\[ \alpha \circ g = h \circ \alpha \]

The Tannakian reconstruction theorem, in this case, tells us that:
\[ \int_F \Set(F *, F *) \cong \cat M (*, *) \]
In other words, we can recover the monoid from its representations.

\subsection{Proof of Tannakian reconstruction}

Monoid reconstruction is a special case of a more general theorem in which the single-object category is replaced with a regular category. As in the monoid case, we'll reconstruct the hom-set, only this time it will be a general hom-set. We'll prove the formula:
\[ \int_{F \colon [\cat C, \Set]} \Set (F a, F b) \cong \cat C(a, b) \]
The trick is to use the Yoneda lemma to represent the action of $F$:
\[ F a \cong [\cat C, \Set] ( \cat C (a ,-), F) \]
and the same for $F b$. We get:
\[ \int_{F \colon [\cat C, \Set]} \Set ([\cat C, \Set] ( \cat C (a ,-), F), [\cat C, \Set] ( \cat C (b ,-), F)) \]
The two sets of natural transformations here are hom-sets in $[\cat C, \Set]$. 

Recall the corollary to the Yoneda lemma that works for any category $\cat A$:
\[ [\cat A, \Set] (\cat A (x, -), \cat A (y, -)) \cong \cat A (y, x) \]
We can write it using an end:
\[ \int_{z \colon \cat C} \Set (\cat A (x, z), \cat A (y, z)) \cong \cat A (y, x) \]
In particular, we can replace $\cat A$ with the functor category $[\cat C, \Set]$. We get:
\[ \int_{F \colon [\cat C, \Set]} \Set ([\cat C, \Set] ( \cat C (a ,-), F), [\cat C, \Set] ( \cat C (b ,-), F)) \cong [\cat C, \Set](\cat C (b ,-), \cat C (a ,-))\]
We can then apply the Yoneda lemma again to the right hand side to get:
\[ \cat C (a, b) \]
which is exactly the sought after result.

\subsection{Tannakian reconstruction in Haskell}

We can immediately translate this result to Haskell. We replace the end by \hask{forall}. The left hand side becomes:
\begin{haskell}
forall f. Functor f => f a -> f b
\end{haskell}
and the right hand side is the function type \hask{a->b}. 

We've seen polymorphic functions before: they were functions defined for all types, or sometimes for classes of types. Here we have a function that is defined for all functors. It says: give me a functorful of \hask{a}'s and I'll produce a functorful of \hask{b}'s---no matter what functor you use. The only way this can be implemented (using parametric polymorphism) is if this function has secretly captured a function of the type \hask{a->b} and is applying it using \hask{fmap}. 

Indeed, one direction of the isomorphism is just that: capturing a function and \hask{fmap}ping it over the argument:
\begin{haskell}
toRep :: (a -> b) -> (forall f. Functor f => f a -> f b)
toRep g fa = fmap g fa
\end{haskell}
The other direction uses the identity trick:
\begin{haskell}
fromRep :: (forall f. Functor f => f a -> f b) -> (a -> b)
fromRep g a = unId (g (Id a))
\end{haskell}
where the identity functor is defined as:
\begin{haskell}
data Id a = Id a 
  
unId :: Id a -> a
unId (Id a) = a

instance Functor Id where
  fmap g (Id a) = Id (g a)
\end{haskell}

This kind of reconstruction might seem trivial and pointless. Why would anyone want to replace function type \hask{a->b} with a much more complicated type:
\begin{haskell}
type Getter a b = forall f. Functor f => f a -> f b
\end{haskell}
It's instructive, though, to think of \hask{a->b} as the precursor of all optics. It's a lens that focuses on the $b$ part of $a$. It tells us that $a$ contains enough information, in one form or another, to construct an $b$. It's a ``getter'' or an ``accessor.'' 

Obviously, functions compose. What's interesting though is that functor representations also compose, and they compose using simple function composition:
\begin{haskell}
boolToStrGetter :: Getter Bool String
boolToStrGetter = toRep (show) . toRep (bool 0 1)
\end{haskell}
Other optics don't compose so easily, but their functor (and profunctor) representation do. 
\subsection{Pointed getter}

Here's a little toy example in Haskell that illustrates the need for more interesting reconstructions. It's an optic that can either act as a getter or it can return a default value.
\begin{haskell}
data PtdGetter s t = Pt t | Fun (s -> t)
\end{haskell}
We can apply this getter to a source value and get a result:
\begin{haskell}
apply :: PtdGetter s t -> s -> t
apply (Pt t) _ = t
apply (Fun g) s = g s
\end{haskell}

These getters compose, but their composition is non-trivial:
\begin{haskell}
composePG :: PtdGetter x t -> PtdGetter s x -> PtdGetter s t
composePG (Pt t) _ = Pt t
composePG (Fun g) (Pt x) = Pt (g x)
composePG (Fun g) (Fun g') = Fun (g . g')
\end{haskell}
The composition is associative, and there is an identity getter:
\begin{haskell}
idPG :: PtdGetter a a
idPG = Fun id
\end{haskell}
so we do have a category in which pointed getters form hom-sets. 

The functor representation for this toy optic exists, but we have to restrict the type of functors over which we take the end. Here's the definition of a class of \hask{Pointed} functors:
\begin{haskell}
class Functor f => Pointed f where
  eta :: a -> f a
\end{haskell}
Our \hask{PointedGetter} is represented by the following Tannakian-like formula:
\begin{haskell}
type PtdGetterF s t = forall f. Pointed f => f s -> f t
\end{haskell}
This time we are defining a function that is polymorphic not over all functors but over a restricted class of \hask{Pointed} functors.

As before, we can apply this optic to retrieve the target. The trick is to encapsulate the source in the identity functor:
\begin{haskell}
applyF :: PtdGetterF s t -> s -> t
applyF g = unId . g . Id
\end{haskell}
Indeed, the identity functor is pointed:
\begin{haskell}
instance Pointed Id where
  eta = Id
\end{haskell}

The equivalence of the two formulations is witnessed by this pair of functions:
\begin{haskell}
toPGF :: PtdGetter s t -> PtdGetterF s t
toPGF (Pt t) = \_ -> eta t
toPGF (Fun g) = fmap g

fromPGF :: PtdGetterF s t -> PtdGetter s t
fromPGF g = Fun (unId . g . Id)
\end{haskell}
This time, however, the functor representation has definite advantage over the original: a composition of two \hask{PtdGetterF} optics is just function composition.
\begin{exercise}
Define two composable \hask{PtdGetter} optics---for instance, one going from a pair \hask{(Int, Bool)} to \hask{Int} and another from \hask{Int} to \hask{String}. Compose them first using \hask{composePG}, then convert them to the functor representation, and compose them using function composition.
\end{exercise}


\subsection{Tannakian reconstruction with adjunction}

In the toy example, we performed the reconstruction over a category of functors that were equipped with additional structure. In category theory we would describe pointed functors as endofunctors $P \colon \Set \to \Set$ equipped with natural transformations:
\[ \eta \colon Id \to P \]
They form their own category, let's call it $\mathbf{Ptd}$,  with morphisms that are natural transformations that preserve the structure. Such a transformation $\alpha \colon (P, \eta) \to (P', \eta')$ must make the following triangle commute:
\[
 \begin{tikzcd}
 & a
 \arrow[dl, "\eta"']
 \arrow[dr, "\eta'"]
 \\
 P a
 \arrow[rr, "\alpha_a"]
 && P' a
 \end{tikzcd}
\]

Every pointed functor is a functor---a statement that is formalized by saying that there is a forgetful functor $U \colon\mathbf{Ptd} \to [\Set, \Set]$, which forgets the additional structure. Notice that this is a functor between functor categories. 

This functor has a left adjoint. Any endofunctor $P \colon \Set \to \Set$ can be freely made into a pointed functor using the coproduct:
\[ (F Q) a = a + Q a \]
together with a natural transformation:
\[ \eta_a = \text{Left} \]

The trick in generalizing the Tannakian reconstruction is to define the end over a specialized functor category $\cat T$, 
 but applying the forgetful functor to its functors. We assume that we have the free/forgetful adjunction $F \dashv U$:
\[ \cat T (F Q, P) \cong  [\cat C, \Set] ( Q, U P )\]

Our starting point is the end:
\[ \int_{P \colon \cat T} \Set \big((U P) a, (U P) b\big) \]
The mapping $\cat T \to \Set$ given by:
\[ P \mapsto (U P) a \]
is sometimes called a fiber functor, so the end formula can be interpreted as a set of natural transformations between two fiber functors. 

As we did before, we first apply the Yoneda lemma to get:
\[ \int_{P \colon \cat T} \Set \Big([\cat C, \Set] \big( \cat C (a ,-), U P\big), [\cat C, \Set] \big( \cat C (b ,-), U P\big)\Big) \]
We can now use the adjunction:
\[ \int_{P \colon \cat T} \Set \Big(\cat T \big( F \cat C (a ,-), P\big), \cat T \big( F \cat C (b ,-), P\big)\Big) \]
We end up with a mapping between two natural transformations in the functor category $\cat T$. We can simplify it using the corollary to the Yoneda lemma:
\[ \cat T\big( F \cat C (b ,-), F \cat C (a ,-) \big) \]
We apply the adjunction once more:
\[ \cat T\big( \cat C (b ,-), (U\circ F) \cat C (a ,-) \big) \]
and the Yoneda lemma again:
\[ \big( (U\circ F) \cat C (a ,-) \big) b \]
The final observation is that the compostion $U \circ F$ of adjoint functors is a monad in the functor category. Let's call this monad $\Phi$. The result is the following identity that will serve as the foundation for profunctor optics:
\[ \int_{P \colon \cat T} \Set \big((U P) a, (U P) b\big) \cong \big( \Phi \cat C (a ,-) \big) b \]
The right-hand side is the action of the monad $\Phi = U \circ F$ on the representable functor $\cat C (a, -)$ evaluated at $b$. 

In our toy example, the monad $\Phi$ is given by:
\[ (\Phi Q) b = b + Q b \]
which is just the action of the free functor $F$ followed by forgetting the $\eta$. Replacing $Q$ with the representable $\cat C (a, -)$ we get:
\[ b + \cat C (a, b) \]
In Haskell, this translates directly to our \hask{PtdGetter}.

\end{document}